# 枚举算法
枚举算法的核心思想是：通过列举问题的所有状态，将它们逐一与目标状态进行比较，从而得到满足条件的解

采用枚举算法解题的一般思路如下：
1. 确定枚举对象、枚举范围和判断条件，并判断条件设立的正确性。
2. 一一枚举可能的情况，并验证是否是问题的解。
3. 考虑提高枚举算法的效率。

leetcode题目：两数之和

# 递归算法
> 递归（Recursion）：指的是一种通过重复将原问题分解为同类的子问题而解决的方法。

我们可以把「递归」分为两个部分：「递推过程」和「回归过程」。
- 递推过程：指的是将原问题一层一层地分解为与原问题形式相同、规模更小的子问题，直到达到结束条件时停止，此时返回最底层子问题的解。
- 回归过程：指的是从最底层子问题的解开始，逆向逐一回归，最终达到递推开始时的原问题，返回原问题的解。

「递推过程」和「回归过程」是递归算法的精髓。从这个角度来理解递归，递归的基本思想就是： **把规模大的问题不断分解为子问题来解决**。

我们可以按照这个思想来书写递归，具体步骤如下：
1. 写出递推公式：找到将原问题分解为子问题的规律，并且根据规律写出递推公式。
2. 明确终止条件：推敲出递归的终止条件，以及递归终止时的处理方法。
3. 将递推公式和终止条件翻译成代码：
   - 定义递归函数（明确函数意义、传入参数、返回结果等）。
   - 书写递归主体（提取重复的逻辑，缩小问题规模）。
   - 明确递归终止条件（给出递归终止条件，以及递归终止时的处理方法）

leetcode题目：斐波那契数，二叉树的最大深度

## 递归与动态规划的区别

1. 重复子问题的处理：在递归中，相同的子问题可能会被重复计算多次，这会导致效率低下。而在动态规划中，重复的子问题只会被计算一次并被存储起来，避免了不必要的重复计算。
2. 问题的规模：递归通常通过缩小问题的规模来解决原始问题，这意味着每次递归调用都会处理更小的数据集。而动态规划则通过存储和重用子问题的解来提高效率，不一定要缩小问题的规模。
3. 空间复杂度：由于动态规划需要存储子问题的解，因此其空间复杂度通常较高。而递归的空间复杂度取决于具体实现和问题的性质。
4. 应用范围：递归和动态规划各有其适用的场景。递归更适用于问题可以被清晰地分解为更小的子问题的情况，而动态规划则更适用于子问题之间存在重叠的情况。  
综上所述，递归和动态规划是两种不同的解决问题的方法。递归注重将问题分解为更小的子问题并逐个解决它们，而动态规划则通过存储和重用子问题的解来提高效率。在实际应用中，选择使用递归还是动态规划取决于具体问题的性质和要求。

# 分治算法
> 分治算法（Divide and Conquer）：字面上的解释是「分而治之」，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。

简单来说，分治算法的基本思想就是： **把规模大的问题不断分解为子问题，使得问题规模减小到可以直接求解为止**。

使用分治算法解决问题主要分为3个步骤：
1. 分解：把要解决的问题分解为成若干个规模较小、相对独立、与原问题形式相同的子问题。
2. 求解：递归求解各个子问题。
3. 合并：按照原问题的要求，将子问题的解逐层合并构成原问题的解。

分治算法的应用：
- 归并排序
- 二分查找

## 分治算法和递归算法的异同
从定义上来看，分治算法的思想和递归算法的思想是一样的，都是把规模大的问题不断分解为子问题。

其实，分治算法和递归算法的关系是包含与被包含的关系，可以看做： 递归算法 ∈ 分治算法。

分治算法从实现方式上来划分，可以分为两种：「递归算法」和「迭代算法」

# 回溯算法
>回溯算法（Backtracking）：一种能避免不必要搜索的穷举式的搜索算法。采用试错的思想，在搜索尝试过程中寻找问题的解，当探索到某一步时，发现原先的选择并不满足求解条件，或者还需要满足更多求解条件时，就退回一步（回溯）重新选择，这种走不通就退回再走的技术称为「回溯法」，而满足回溯条件的某个状态的点称为「回溯点」

简单来说，回溯算法采用了一种 「走不通就回退」 的算法思想。

回溯算法通常用简单的递归方法来实现，在进行回溯过程中更可能会出现两种情况：
1. 找到一个可能存在的正确答案；
2. 在尝试了所有可能的分布方法之后宣布该问题没有答案。

回溯算法的基本思想是：**以深度优先搜索的方式，根据产生子节点的条件约束，搜索问题的解。当发现当前节点已不满足求解条件时，就「回溯」返回，尝试其他的路径**。

leetcode题目：子集，N皇后

# 贪心算法
> 贪心算法（Greedy Algorithm）：一种在每次决策时，总是采取在当前状态下的最好选择，从而希望导致结果是最好或最优的算法。

对许多问题来说，可以使用贪心算法，通过局部最优解而得到整体最优解或者是整体最优解的近似解。但并不是所有问题，都可以使用贪心算法的。

一般来说，这些能够使用贪心算法解决的问题必须满足下面的两个特征：
1. 贪⼼选择性质：指的是一个问题的全局最优解可以通过一系列局部最优解（贪心选择）来得到。
2. 最优子结构：指的是一个问题的最优解包含其子问题的最优解。

leetcode题目：分发饼干，无重叠区间

# 位运算
基本的位运算共有6种，分别是：「按位与运算」、「按位或运算」、「按位异或运算」、「取反运算」、「左移运算」、「右移运算」。

取反运算规则：使数字 111 变为 000，000 变为 111。
1. `~0 = 1`
2. `~1 = 0`

## 位运算的应用
### 判断整数奇偶
1. (x & 1) == 0 为偶数。
2. (x & 1) == 1 为奇数。

### 二进制数选取指定位
如果我们想要从一个二进制数 XXX 中取出某几位，使取出位置上的二进位保留原值，其余位置为 000，则可以使用另一个二进制数 YYY，使该二进制数上对应取出位置为 111，其余位置为 000。然后令两个数进行按位与运算（X & Y），即可得到想要的数。

举例：取`01101010`的末尾4位，只需`01101010 & 00001111 == 00001010`即可

### 将指定位设置为1
`01101010 | 00001111 = 01101111`

### 反转指定位
将`01101010`的末尾4位进行反转：`01101010 ^ 00001111 = 01100101`

### 交换两个整数
```javascript
a, b = 10, 20
a ^= b
b ^= a
a ^= b
```

### 将二进制最右侧为1的二进位改为0
只需通过 X & (X - 1) 的操作即可完成

### 计算二进制中二进位为1的个数
不断通过 X & (X - 1) 操作，最终将二进制 X 变为 0，并统计执行次数，则可以得到二进制中二进位为 1 的个数。

### 判断某数是否为2的幂次方
通过判断 X & (X - 1) == 0 是否成立，即可判断 XXX 是否为 222 的幂次方。

## 总结
| 功能 | 位运算 | 示例
| :-----| :---- | :----
| 从右边开始，把最后一个 1 改写成 0 | x & (x - 1) | 100101000 -> 100100000  
| 去掉右边起第一个 1 的左边  | x & (x ^ (x - 1)) 或 x & (-x)  | 100101000 -> 1000  
| 去掉最后一位 | x >> 1 | 101101 -> 10110  
| 取右数第 k 位 | x >> (k - 1) & 1 | 1101101 -> 1, k = 4  
| 取末尾 3 位 | x & 7 | 1101101 -> 101  
| 取末尾 k 位  | x & 15  | 1101101 -> 1101, k = 4  
| 只保留右边连续的 1 |  (x ^ (x + 1)) >> 1 |  100101111 -> 1111  
| 右数第 k 位取反 |  x ^ (1 << (k - 1))  | 101001 -> 101101, k = 3  
| 在最后加一个 0 |  x << 1  | 101101 -> 1011010  
| 在最后加一个 1  | (x << 1) + 1 |  101101 -> 1011011  
| 把右数第 k 位变成 0 |  x & ~(1 << (k - 1)) |  101101 -> 101001, k = 3  
| 把右数第 k 位变成 1 |  x \| (1 << (k - 1)) |  101001 -> 101101, k = 3  
| 把右边起第一个 0 变成 1 | x \| (x + 1) | 100101111 -> 100111111  
| 把右边连续的 0 变成 1 | x \| (x - 1) | 11011000 -> 11011111  
| 把右边连续的 1 变成 0 | x & (x + 1) | 100101111 -> 100100000  
| 把最后一位变成 0 | x \| 1 - 1 | 101101 -> 101100  
| 把最后一位变成 1 | x \| 1 | 101100 -> 101101  
| 把末尾 k 位变成 1 | x \| (1 << k - 1) | 101001 -> 101111, k = 4  
| 最后一位取反 | x ^ 1 | 101101 -> 101100  
| 末尾 k 位取反 | x ^ (1 << k - 1) | 101001 -> 100110, k = 4  